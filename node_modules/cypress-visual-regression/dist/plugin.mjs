import {
  adjustCanvas,
  parseImage
} from "./chunk-2KQOHPDY.mjs";
import {
  logger
} from "./chunk-4UFQ72U2.mjs";

// src/plugin.ts
import { createWriteStream, promises as fs, renameSync, existsSync, mkdirSync, readdirSync, rmdirSync } from "fs";
import * as path from "path";
import pixelMatch from "pixelmatch";
import { PNG } from "pngjs";
import sanitize from "sanitize-filename";
var updateSnapshot = async (options) => {
  const toDir = options.baseDirectory ?? path.join(process.cwd(), "cypress", "snapshots", "base");
  const destDir = path.join(toDir, options.spec.relative);
  const destFile = path.join(destDir, `${options.screenshotName}.png`);
  try {
    await fs.mkdir(destDir, { recursive: true });
  } catch (error) {
    logger.error(`Failed to create directory '${destDir}' with error:`, error);
    throw new Error(`cannot create directory '${destDir}'.`);
  }
  try {
    await fs.copyFile(options.screenshotAbsolutePath, destFile);
    logger.info(`Updated base snapshot '${options.screenshotName}' at ${destFile}`);
    logger.debug("UpdateSnapshotOptions: ", JSON.stringify(options, void 0, 2));
    moveActualSnapshotIfNeeded(options.screenshotAbsolutePath, options.spec.relativeToCommonRoot);
    return { baseGenerated: true };
  } catch (error) {
    logger.error(`Failed to copy file '${destDir}' with error:`, error);
    throw new Error(`Failed to copy file from '${options.screenshotAbsolutePath}' to '${destFile}'.`);
  }
};
var moveActualSnapshotIfNeeded = (actualScreenshot, relativeToCommonRoot) => {
  if (relativeToCommonRoot != null) {
    const newPath = actualScreenshot.replace(relativeToCommonRoot + "/", "");
    const newDirectory = path.dirname(newPath);
    try {
      if (!existsSync(newDirectory)) {
        mkdirSync(newDirectory, { recursive: true });
      }
      renameSync(actualScreenshot, newPath);
      pruneEmptyDirectoriesInverse(path.dirname(actualScreenshot));
    } catch (error) {
      logger.error(`Failed to move file '${actualScreenshot}' with error:`, error);
      throw new Error(`Failed to move file  '${actualScreenshot}' to '${newPath}'.`);
    }
  }
  return true;
};
var pruneEmptyDirectoriesInverse = (directory) => {
  if (readdirSync(directory).length === 0) {
    rmdirSync(directory);
    logger.debug(`Removed empty directory: ${directory}`);
    pruneEmptyDirectoriesInverse(path.dirname(directory));
  }
};
var compareSnapshots = async (options) => {
  const snapshotBaseDirectory = options.baseDirectory ?? path.join(process.cwd(), "cypress", "snapshots", "base");
  const snapshotDiffDirectory = options.diffDirectory ?? path.join(process.cwd(), "cypress", "snapshots", "diff");
  const fileName = sanitize(options.screenshotName);
  const actualImage = options.screenshotAbsolutePath;
  const expectedImage = path.join(snapshotBaseDirectory, options.spec.relative, `${fileName}.png`);
  const diffImage = path.join(snapshotDiffDirectory, options.spec.relative, `${fileName}.png`);
  const [imgExpected, imgActual] = await Promise.all([parseImage(expectedImage), parseImage(actualImage)]);
  const diffPNG = new PNG({
    width: Math.max(imgActual.width, imgExpected.width),
    height: Math.max(imgActual.height, imgExpected.height)
  });
  const imgActualFullCanvas = adjustCanvas(imgActual, diffPNG.width, diffPNG.height);
  const imgExpectedFullCanvas = adjustCanvas(imgExpected, diffPNG.width, diffPNG.height);
  const mismatchedPixels = pixelMatch(
    imgActualFullCanvas.data,
    imgExpectedFullCanvas.data,
    diffPNG.data,
    diffPNG.width,
    diffPNG.height,
    { threshold: 0.1 }
  );
  const percentage = (mismatchedPixels / diffPNG.width / diffPNG.height) ** 0.5;
  if (percentage > options.errorThreshold) {
    logger.error(`Error in visual regression found: ${percentage.toFixed(2)}`);
    if (options.generateDiff !== "never") {
      await generateImage(diffPNG, diffImage);
    }
    return {
      error: `The "${fileName}" image is different. Threshold limit exceeded!
       Expected: ${options.errorThreshold}
       Actual: ${percentage}`,
      mismatchedPixels,
      percentage
    };
  } else if (options.generateDiff === "always") {
    await generateImage(diffPNG, diffImage);
  }
  return {
    mismatchedPixels,
    percentage
  };
};
async function generateImage(diffPNG, imagePath) {
  const dirName = path.dirname(imagePath);
  try {
    await fs.mkdir(dirName, { recursive: true });
  } catch (error) {
    logger.error(`Failed to create directory '${dirName}' with error:`, error);
    throw new Error(`cannot create directory '${dirName}'.`);
  }
  return await new Promise((resolve, reject) => {
    const file = createWriteStream(imagePath);
    file.on("error", (error) => {
      logger.error(`Failed to write stream '${imagePath}' with error:`, error);
      reject(new Error(`cannot create file '${imagePath}'.`));
    });
    diffPNG.pack().pipe(file).on("finish", () => {
      resolve(true);
    }).on("error", (error) => {
      logger.error(`Failed to parse image '${imagePath}' with error:`, error);
      reject(error);
    });
  });
}
var configureVisualRegression = (on) => {
  on("task", {
    compareSnapshots,
    updateSnapshot
  });
};
export {
  compareSnapshots,
  configureVisualRegression,
  generateImage,
  updateSnapshot
};
